/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RpcService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jsbn { namespace rpc { namespace bc {

int _kCityIDValues[] = {
  CityID::CID_INIT,
  CityID::CID_CQ,
  CityID::CID_CD,
  CityID::CID_HZ
};
const char* _kCityIDNames[] = {
  "CID_INIT",
  "CID_CQ",
  "CID_CD",
  "CID_HZ"
};
const std::map<int, const char*> _CityID_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCityIDValues, _kCityIDNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


UserInfo::~UserInfo() throw() {
}


void UserInfo::__set_userId(const int32_t val) {
  this->userId = val;
}

void UserInfo::__set_userName(const std::string& val) {
  this->userName = val;
}

void UserInfo::__set_text(const std::string& val) {
  this->text = val;
}

void UserInfo::__set_cityID(const CityID::type val) {
  this->cityID = val;
__isset.cityID = true;
}

void UserInfo::__set_language(const std::string& val) {
  this->language = val;
__isset.language = true;
}

uint32_t UserInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_userId = false;
  bool isset_userName = false;
  bool isset_text = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          isset_userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          isset_userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          isset_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->cityID = (CityID::type)ecast0;
          this->__isset.cityID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->language);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_userId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_userName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_text)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserInfo");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cityID) {
    xfer += oprot->writeFieldBegin("cityID", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->cityID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.language) {
    xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->language);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserInfo &a, UserInfo &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.userName, b.userName);
  swap(a.text, b.text);
  swap(a.cityID, b.cityID);
  swap(a.language, b.language);
  swap(a.__isset, b.__isset);
}

UserInfo::UserInfo(const UserInfo& other1) {
  userId = other1.userId;
  userName = other1.userName;
  text = other1.text;
  cityID = other1.cityID;
  language = other1.language;
  __isset = other1.__isset;
}
UserInfo& UserInfo::operator=(const UserInfo& other2) {
  userId = other2.userId;
  userName = other2.userName;
  text = other2.text;
  cityID = other2.cityID;
  language = other2.language;
  __isset = other2.__isset;
  return *this;
}
void UserInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserInfo(";
  out << "userId=" << to_string(userId);
  out << ", " << "userName=" << to_string(userName);
  out << ", " << "text=" << to_string(text);
  out << ", " << "cityID="; (__isset.cityID ? (out << to_string(cityID)) : (out << "<null>"));
  out << ", " << "language="; (__isset.language ? (out << to_string(language)) : (out << "<null>"));
  out << ")";
}


UserInfoSearchResult::~UserInfoSearchResult() throw() {
}


void UserInfoSearchResult::__set_userinfos(const UserInfoList& val) {
  this->userinfos = val;
}

uint32_t UserInfoSearchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userinfos.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->userinfos.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->userinfos[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userinfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserInfoSearchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserInfoSearchResult");

  xfer += oprot->writeFieldBegin("userinfos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->userinfos.size()));
    std::vector<UserInfo> ::const_iterator _iter8;
    for (_iter8 = this->userinfos.begin(); _iter8 != this->userinfos.end(); ++_iter8)
    {
      xfer += (*_iter8).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserInfoSearchResult &a, UserInfoSearchResult &b) {
  using ::std::swap;
  swap(a.userinfos, b.userinfos);
  swap(a.__isset, b.__isset);
}

UserInfoSearchResult::UserInfoSearchResult(const UserInfoSearchResult& other9) {
  userinfos = other9.userinfos;
  __isset = other9.__isset;
}
UserInfoSearchResult& UserInfoSearchResult::operator=(const UserInfoSearchResult& other10) {
  userinfos = other10.userinfos;
  __isset = other10.__isset;
  return *this;
}
void UserInfoSearchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserInfoSearchResult(";
  out << "userinfos=" << to_string(userinfos);
  out << ")";
}


Unavailable::~Unavailable() throw() {
}


void Unavailable::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t Unavailable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Unavailable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Unavailable");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Unavailable &a, Unavailable &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Unavailable::Unavailable(const Unavailable& other11) : TException() {
  message = other11.message;
  __isset = other11.__isset;
}
Unavailable& Unavailable::operator=(const Unavailable& other12) {
  message = other12.message;
  __isset = other12.__isset;
  return *this;
}
void Unavailable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Unavailable(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* Unavailable::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Unavailable";
  }
}

}}} // namespace
